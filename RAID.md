# RAID

**RAID**  `Redundant Array of Inexpensive Disk` 저렴한 디스크의 복수 배열의 약자입니다. 여러개의 디스크를 배열하여 속도의 증대, 안정성, 효율성, 가용성의 증대를 하는데 쓰이는 기술입니다. <br>
서버의 사용자가 서버 운영에 있어 가장 당혹스러울 때는 하드디스크의 장애로 인한 data 손실입니다. 하드디스크는 사실상 소모품으로 분류되며 I/O가
많은 서버에는 고장이 잦은 것이 당연하다고 볼수 있습니다. 하지만 서버에 저장되는 데이터의 경우 손실 또는 유출 되었을때 치명적인 것이 대부분일 것으로
대표적으로 은행과 같은 금융, 군사적 목적의 데이터가 있을 것입니다. 이로 인해 백업이 절대적으로 필요한 경우가 있고 또한, 여분의 디스크가 있어
용량을 증설하려고 할 때 데이터 손실없이 증설이 필요한 경우가 있습니다. 그래서 많은 서버 관리자는 RAID구성을 통해 하드디스크의 가용성을 높이거나
서버 데이터의 안정성을 확보해야 합니다. <br>
RAID를 사용했을때 기대효과 <br>
 -대용량의 단일 볼륨을 사용하는 효과 <br>
 -디스크I/O 병렬화로 인한 성능 향상 `RAID 0, RAID 5, RAID 6등` <br>
 -데이터 복제로 인한 안정성 향상 `RAID 1 등` <br>
 
----
RAID는 컴퓨터를 구성하는 여러 부품중 기계적인 특성 때문에 상대적으로 속도가 느린 하드디스크를 보완하기 위해 만든 기술입니다. <br>
RAID를 구성하는 디스크의 개수가 같아도, RAID의 구성방식에 따라 성능, 용량이 바뀌게 됩니다. <br>
이 구성방식을 RAID Level 이라고 부르는데 여러가지 방식의 RAID Level이 있습니다.

----
먼저 기본적인 RAID Level `Standard RAID Level`입니다. <br>
최근 출시되는 RAID 컨트롤러에서 사용가능한 RAID Level은 RAID 0, RAID 1, RAID 5, RAID 6 입니다. <br>
RAID를 구성하는 디스크는 종류와 크기가 같은 것을 사용하는 것이 좋습니다.

----
*패리티* `Parity`
 -정수의 홀수 또는 짝수 특성
 -정보 블록과 연결된 중복 정보, 패리티는 오류후 데이터를 재구축하는데 사용되는 계산된 값입니다.
 
----
1. RAID 0 <br>
 -Concatenate 방식 <br>
 두개이상의 디스크에 데이터를 순차적으로 쓰는 방법 <br>
 장점 : 디스크 기본 공간이 부족할 때 데이터는 보존하며 여분의 디스크를 볼륨에 포함하여 용량 증설이 가능하게 됩니다. <br>
 단점 : RAID 0의 특성상 디스크 중 하나의 디스크라도 장애가 발생하면 복구가 어렵고, 패리티(오류검출기능)를 지원하지 않습니다. <br>
 용량 : 모든 디스크의 용량을 합친 용량 ex) 300GB disk * 2ea = 600GB <br>
 -Stripe 방식 <br>
 두개 이상의 디스크에 동시에 데이터를 동일하게 쓰는 방법 <br>
 장점 : 데이터를 사용할 때 I/O를 디스크 수 만큼 분할하여 쓰기 때문에 I/O 속도가 향상 되고I/OController나 I/O board 등 I/O를 담당하는 장치가
 별도로 장착된 경우 더 큰 I/O 속도 향상 효과를 볼 수 있습니다. <br>
 단점 : Stripe를 구성할 시 기존 데이터는 모두 삭제 되어야 합니다. 그 외의 단점은 위의 방식과 같습니다. <br>
 용량 : 위의 방식과 같습니다 
 
----
2. RAID 1 `mirror` <br>
Mirror 볼륨 내의 패리티를 사용하지 않고 디스크에 같은 데이터를 중복 기록하여 데이터를 보존하게 되며, 적어도 동일한 용량의 디스크 두 개가 필요합니다.
장점 : 볼륨 내 디스크 중 하나의 디스크만 정상이어도 데이터는 보존되어 운영이 가능하기 때문에 가용성이 높고, 복원이 비교적 매우 간단합니다. <br>
단점 :  용량이 절반으로 줄고, 쓰기 속도가 조금 느려집니다. <br>
용량 : 모든 디스크의 절반의 용량 ex) 300GB *2ea = 300GB <br>

----
3. RAID 2 <br>
RAID2는 RAID 0처럼 striping 방식이지만 에러 체크와 수정을 할 수 있도록 Hamming code를 사용하고 있는 것이 특징입니다. 하드 디스크에서 
ECC `Error Correction Code` 를 지원하지 않기 때문에 ECC를 별도의 드라이브에 저장하는 방식으로 처리됩니다. 하지만 ECC를 위한 드라이브가 
손상될 경우는 문제가 발생할 수 있으며 패리티 정보를 하나의 하드 드라이브에 저장하는 RAID 4가 나오면서 거의 사용되지 않는 방식입니다.

----
4. RAID 3, RAID 4 <br>
RAID 3, RAID 4는 RAID 0, RAID 1의 문제점을 보완하기 위한 방식으로 3, 4로 나뉘긴 하지만 RAID 구성 방식은 거의 같습니다.
RAID 3, 4는 기본적으로 RAID 0과 같은 striping 구성을 하고 있어 성능을 보안하고 디스크 용량을 온전히 사용할 수 있게 해주는데 
여기에 추가로 에러 체크 및 수정을 위해서 패리티 정보를 별도의 디스크에 따로 저장하게 됩니다.RAID 3은 데이터를 바이트 단위로 나누어 디스크에
동등하게 분산 기록하며 RAID 4는 데이터를 블록 단위로 나눠 기록하므로 완벽하게 동일하진 않다는 차이가 있습니다. 
RAID 3은 드라이브 동기화가 필수적이라 많이 사용되지 않고 RAID 4를 더 많이 쓴다고 보시면 됩니다.

----
5. RAID 5 <br>
RAID 5는 RAID 3,4 에서 별도의 패리티 정보 디스크를 사용함으로써 발생하는 문제점을 보완하는 방식으로 패리티 정보를 stripe로 구성된 디스크 내에서
처리하게 만들었습니다. 만약 1개의 하드가 고장 나더라도 남은 하드들을 통해 데이터를 복구할 수 있다는 장점이 있습니다.

----
6. RAID 6 <br>
RAID 6은 RAID 5와 같은 개념이지만 다른 드라이브들 간에 분포되어 있는 2차 패리티 정보를 넣어 2개의 하드에 문제가 생겨도 복구할 수 있게
설계되었으므로 RAID 5보다 더욱 데이터의 안전성을 고려하는 시스템에서 사용됩니다.

----
**Nested RAID `중첩 RAID`** <br>
Nested RAID는 Standard RAID를 여러개 중첩하여 사용합니다. 즉 복수의 Standard RAID를 또 RAID로 묶습니다. <br>
예를 들어 2개의 RAID 0를 RAID 1로 묶습니다. `RAID 0+1 혹은 RAID01` <br>
2개의 RAID 1을 RAID 0로 묶을 수도 있습니다. `RAID 1+0 혹은 RAID 10` <br>
2개의 RAID 1을 묶은 RAID 0 2개를 RAID 0로 묶는 경우도 있는 것 같습니다. `RAID 10+0`
