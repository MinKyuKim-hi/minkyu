1.TCP(Transmission Control Protocol) <br>
TCP를 해석하면 전송을 제어하는 프로토콜(규약)이라는 뜻이며 `인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜` 이라고 
정의할 수 있습니다. 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리하게 됩니다. <br>
TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용합니다. <br>
**TCP의 특징** <br>
- 연결형 서비스로 가상 회선 방식을 제공한다.
- 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point)방식.

-----
TCP가 가상 회선 방식을 제공한다는 것은 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말입니다. 그리고 3-way handshaking과
정은 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서 세션을 수립하는 과정을 의미합니다. TCP가 이러한 특징을 지니는 이유는 간단명료합니다.
바로 TCP는 연결형 서비스로 신뢰성을 보장하기 때문입니다. 그래서 3-way handshaking의 과정도 사용하는 것이고, 데이터의 흐름제어나 혼잡제어와 같은 기능
도 합니다. 하지만 이러한 기능 때문에 UDP보다 속도가 느리게 됩니다.(이러한 기능은 CPU를 사용하기 때문에 속도에 영향을 주는 것입니다.) 그렇기에 TCP는 
연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜 입니다.

-----
**TCP서버의 특징** <br>
- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된 다형 서비스로 가상 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간지연, CPU소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)


-----
2.UDP(User Datagram Protocol) <br>
UDP를 해석하면 사용자 데이터그램 프로토콜(규약)이라는 뜻이며 `데이터를 데이터그램 단위로 처리하는 프로토콜` 이라고 정의할 수 있습니다. <br>
데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻으로, UDP의 동작방식을 설명하자면 다음과 같습니다. TCP와 달리 UDP는 비연결형 프로토콜입니다. 즉,
연결을 위해 할당되는 논리적인 경로가 없는데, 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되는데 이렇게 
데이터를 서로 다른 경로로 독립적으로 처리하게 되고, 이러한 프로토콜을 UDP라고 합니다. 

-----
**UDP의 특징** <br>
- 비연결형 서비스로 데이터그램 방식을 제공한다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.

-----
UDP는 비연결형 서비스이기 때문에 연결을 설정하고 해제하는 과정이 존재하지 않습니다. 서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 
재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만 데이터의 전송을 
보장하지는 못합니다. 그렇기 때문에 신뢰성보다는 연속성이 중요한 서비스 예를들면 `실시간 서비스(Streaming)`에 자주 사용됩니다.

-----
**UDP서버의 특징**
- UDP에는 연결 자체가 없어서 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1 N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

-----
*흐름제어(flow control)와 혼잡제어(congestion control)란?* <br>
- 흐름제어는 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 것입니다. <br>
수신측에서 송신측보다 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생깁니다. 수신측에서 제한된 저장용량을 초과한 이후에 도착하는 데이터는 
손실 될 수 있으며 만약 손실된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번하게 발생합니다. 따라서 이러한 위험을 줄이기 위해 송신 측의
데이터 전송량을 수신측에 따라 조절해야 합니다. <br>
내부 방식으로 Stop wait 방식, Sliding Window 방식이 있습니다. <br>
Stop wait 방식 : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법 <br>
Sliding Window 방식 : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 해서 데이터 흐름을 동적으로 조절하는  
제어 방법 <br>
동작 방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송.
Window : TCP/IP를 사용하는 모든 호스트들은 보내기 위한것, 받기 위한것 2개의 Window를 가지고 있습니다. 호스트들은 실제 데이터를 보내기 전에 먼저 
앞에서 포스팅했던 ' TCP 3-way-handshaking' 을 통해 수신 컴퓨터의 receive window size에 자신의 send window size를 맞추게 됩니다. 즉 상대방이 
받을 수 있는 크기에 맞춰 전송을 하게 됩니다. <br>
- 혼잡제어는 송신 측의 데이터 전달과 데이터 처리 속도 차이를 해결하기 위한 것입니다. <br>
송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됩니다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리
할 수 없게 됩니다. 이런 경우 호스트들은 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 됩니다. 따라서 이러한 
네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라 합니다.  <br>
또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라고 하며 혼잡현상을 방지하거나 제거하는 기능을 혼잡제어 라고 합니다. 흐름제어가 
송신측과 수신측 사이의 전송속도를 다루는데 반해 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서의 전송 문제를 다루게 됩니다. <br>
혼잡제어 알고리즘(AIMD-Additive Increase/ Multicative Decrease) <br>
처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window크기 ( 단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법입니다. <br>
만일 패킷 전송을 실패하거나 일정 시간을 넘으면 패킷을 보내는 속도를 절반으로 줄이게 됩니다. <br>
이 방식은 공평한 방식으로, 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면
평형 상태로 수렴하게 되는 특징이 있습니다. <br>
문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다는 점입니다.
즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이라고 할 수 있습니다.<br>
Slow start(느린시작) : 합 증가/곱 감소 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는데 걸리는 시간이 너무 길
다는 단점이 있습니다. 느린시작 방식은 합 증가/곱 감소 와는 다르게 지수 함수 꼴로 증가하게 됩니다. 대신에 혼잡 현상이 발생하면 Window size를 1로 
떨어뜨리게 됩니다. 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수
있으므로 혼잡 현상이 발생하였던 Window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식
입니다. <br>
초기에 지수 함수꼴로 창 크기를 빠르게 증가시키는 방식의 이름이 느린 시작인 것이 어울리지 않는 것이라고 생각할 수도 있습니다. 하지만 느린 시작의 
의미는 선형 증가 방식과 비교해서는 안되고 느린 시작이 발명 되었을 당시 TCP의 동작 방식과 비교해야 합니다. 이전의 TCP 동작은 처음에 최대한 보낼 수 
있는 만큼의 패킷을 보내는 것으로 시작하고, 느린 시작은 이것과 달리 창 크기를 1에서부터 시작하여 지수 함수 꼴로 증가 시키면서 네트워크의 수용량을 
감지합니다. 이방식은 합 증가/곱 감소 방식보다 더 효율적인 방법이지만 혼잡한 상황이 된 겨우에는 타임아웃이 될 때까지 기다리는 동안 큰 시간의 공백이 
있습니다. <br>
Fast Retransmit(빠른 재전송) : 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책입니다. 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 
패킷이 도착한 경우에도 ACK패킷을 보내게 됩니다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK패킷에 실어서 보내게 되므로 중간에 패
킷 하나가 손실되게 되면 보내는 측에서는 순번이 중복된 ACK패킷을 받게 되고, 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송해 줄 수 있습니다.
빠른 재전송은 중복된 순번의 패킷을 3개 받으면 재전송을 하게 됩니다. 이런 현상이 일어나는 것은 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고
Window size를 줄이게 됩니다. <br>
Fast Recovery(빠른 회복) : 빠른 회복 정책은 혼잡한 상태가 되면 Window size를 1로 줄이지 않고 반으로 줄이고 선형을 증가시키는 방법입니다. 빠른 
회복 정책 까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 합 증가/곱 감소 방식으로 동작하게 됩니다. <br>
TCP리노 방식은 느린시작, 빠른 재전송, 빠른 회복 세가지 모두를 구현하며, 마이크로소프트 윈도우 운영체제도 이 방식으로 동작합니다.

-----
3.TCP와 UDP의 비교 <br>
<img width="387" alt="990C0F3359FDD3F80C" src="https://user-images.githubusercontent.com/63625609/82962934-9181cf80-9ffc-11ea-8f8c-d6cea0935c60.png">

-----
*교환방식* <br>
<img width="262" alt="99816B3359FDD25205" src="https://user-images.githubusercontent.com/63625609/82963030-c8f07c00-9ffc-11ea-8d6f-09bcde71b54e.png"> <br>
*UDP Flow* <br>
<img width="410" alt="99C5C63359FEB5DC06" src="https://user-images.githubusercontent.com/63625609/82963084-e7567780-9ffc-11ea-9cbd-217b517f6fdc.png"> <br>
*TCP Flow* <br>
<img width="410" alt="9934293359FEB5EE38" src="https://user-images.githubusercontent.com/63625609/82963132-fe956500-9ffc-11ea-84e0-8f57e2ce2f5f.png">
